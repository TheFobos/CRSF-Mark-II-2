# CRSF API Server и Interpreter

## Описание

Система API сервера и интерпретатора позволяет управлять CRSF через HTTP API, обеспечивая прозрачность для основной программы.

## Архитектура

### Схема без API (текущая):
```
[ведущий] -> сервер -> программа
```

### Схема с API:
```
[ведущий] -> API сервер -> HTTP API -> [ведомый] -> API интерпретатор -> программа
```

**Важно:** Программа на ведомом узле не знает разницы между прямым управлением и управлением через API, так как интерпретатор записывает команды в тот же файл `/tmp/crsf_command.txt`.

## Компоненты

### 1. API Server (`crsf_api_server`)

**Расположение:** Ведущий узел

**Функции:**
- Принимает HTTP запросы с командами управления
- Перенаправляет команды на ведомый узел через HTTP API

**Использование:**
```bash
./crsf_api_server [порт] [целевой_хост] [целевой_порт]
```

**Параметры:**
- `порт` - порт для прослушивания входящих команд (по умолчанию: 8081)
- `целевой_хост` - IP адрес или имя ведомого узла (по умолчанию: localhost)
- `целевой_порт` - порт API интерпретатора на ведомом узле (по умолчанию: 8082)

**Пример:**
```bash
./crsf_api_server 8081 192.168.1.100 8082
```

### 2. API Interpreter (`crsf_api_interpreter`)

**Расположение:** Ведомый узел

**Функции:**
- Получает команды через HTTP API от API сервера
- Записывает команды в файл `/tmp/crsf_command.txt` (как это делает pybind)
- Обеспечивает прозрачность для основной программы

**Использование:**
```bash
./crsf_api_interpreter [порт]
```

**Параметры:**
- `порт` - порт для прослушивания входящих команд (по умолчанию: 8082)

**Пример:**
```bash
./crsf_api_interpreter 8082
```

## API Endpoints

### API Server (ведущий узел)

Все endpoints принимают POST запросы с JSON телом.

#### POST /api/command/setChannel
Установка одного канала.

**Тело запроса:**
```json
{
  "channel": 1,
  "value": 1500
}
```

**Пример:**
```bash
curl -X POST http://localhost:8081/api/command/setChannel \
  -H "Content-Type: application/json" \
  -d '{"channel":1,"value":1500}'
```

#### POST /api/command/setChannels
Установка всех каналов одновременно.

**Тело запроса:**
```json
{
  "channels": [1500, 1600, 1700, 1800, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500]
}
```

**Пример:**
```bash
curl -X POST http://localhost:8081/api/command/setChannels \
  -H "Content-Type: application/json" \
  -d '{"channels":[1500,1600,1700,1800,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500]}'
```

#### POST /api/command/sendChannels
Отправка каналов.

**Тело запроса:**
```json
{}
```

**Пример:**
```bash
curl -X POST http://localhost:8081/api/command/sendChannels \
  -H "Content-Type: application/json" \
  -d '{}'
```

#### POST /api/command/setMode
Установка режима работы.

**Тело запроса:**
```json
{
  "mode": "joystick"
}
```
или
```json
{
  "mode": "manual"
}
```

**Пример:**
```bash
curl -X POST http://localhost:8081/api/command/setMode \
  -H "Content-Type: application/json" \
  -d '{"mode":"joystick"}'
```

### API Interpreter (ведомый узел)

API интерпретатор имеет те же endpoints, но они используются внутренне API сервером для передачи команд.

## Формат команд в файле

API интерпретатор записывает команды в `/tmp/crsf_command.txt` в том же формате, что и pybind:

- `setChannel <номер> <значение>` - установка одного канала
- `setChannels 1=1500 2=1600 ...` - установка всех каналов
- `sendChannels` - отправка каналов
- `setMode <режим>` - установка режима (joystick/manual)

## Пример использования

### Настройка на двух узлах

**Ведущий узел (192.168.1.50):**
```bash
# Запуск API сервера
./crsf_api_server 8081 192.168.1.100 8082
```

**Ведомый узел (192.168.1.100):**
```bash
# Запуск основной программы
./crsf_io_rpi

# В другом терминале - запуск API интерпретатора
./crsf_api_interpreter 8082
```

### Отправка команд с ведущего узла

```bash
# Установка канала 1 в значение 1500
curl -X POST http://localhost:8081/api/command/setChannel \
  -H "Content-Type: application/json" \
  -d '{"channel":1,"value":1500}'

# Установка режима joystick
curl -X POST http://localhost:8081/api/command/setMode \
  -H "Content-Type: application/json" \
  -d '{"mode":"joystick"}'
```

## Преимущества

1. **Прозрачность:** Программа на ведомом узле не требует изменений
2. **Гибкость:** Можно использовать как с API, так и без него
3. **Совместимость:** Использует тот же формат команд, что и pybind
4. **Независимость:** Программа работает одинаково независимо от способа управления

## Сборка

Компоненты собираются вместе с основным приложением:

```bash
make
```

Это создаст:
- `crsf_io_rpi` - основное приложение
- `crsf_api_server` - API сервер
- `crsf_api_interpreter` - API интерпретатор

## Использование с графическим интерфейсом

Графический интерфейс `crsf_realtime_interface.py` может работать как через pybind (на ведомом узле), так и через API (на ведущем узле).

### На ведомом узле (обычный режим):
```bash
python3 crsf_realtime_interface.py
```

### На ведущем узле (API режим):
```bash
python3 crsf_realtime_interface.py --api --api-url http://localhost:8081
```

**Параметры:**
- `--api` - включить API режим
- `--api-url` - URL API сервера (по умолчанию: http://localhost:8081)

**Примечание:** В API режиме телеметрия недоступна, так как API сервер не предоставляет телеметрию. Интерфейс будет показывать пустые данные, но команды управления будут работать.

## Примечания

- API сервер и интерпретатор должны быть запущены на соответствующих узлах
- Убедитесь, что порты не заняты другими приложениями
- Для работы через сеть убедитесь, что порты открыты в firewall
- API интерпретатор должен иметь права на запись в `/tmp/crsf_command.txt`
- Для работы интерфейса в API режиме требуется установленный модуль `requests` (pip install requests)
